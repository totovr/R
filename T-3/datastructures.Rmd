---
title: "Data Structure"
author: "Antonio Vega"
output:
  ioslides_presentation:
    css: ../JB_style.css
    logo: ../Imgs/LogoCurso.png
    widescreen: yes
  slidy_presentation: default
  beamer_presentation: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment = NA)
```

# Vectors

## Data types in R

A **vector** is an ordered sequence of data. `R` has many types of data, for example:

- `logical`: logical (``` TRUE``` or ```FALSE```)
- `integer`: whole numbers, $\mathbb Z$
- `numeric`: real numbers, $\mathbb R$
- `complex`: complex numbers, $\mathbb C$
- `character`: words

In the vectors of `R`, all their objects must be of the same type: all numbers, all words, etc. When we want to use vectors formed by objects of different types, we will have to use **generalized lists**, 'lists' that we will see at the end of the topic.

## Basic

- ```c()```: to define a vector
- ```scan()```: to define a vector
- ```fix(x)```: to visually modify the vector $x$
- ```rep(a, n)```: to define a constant vector that contains the data $a$ repeated $n$ times

```{r example_rep}
c(1,2,3)
rep("Tono",5)
```


## scan() function 

This functions also work with URL with text files

**Example**

This is an example of how to create a vector that contains 3 copies of 1 9 9 8 0 7 2 6 with the scan function:
<div class = "aligncenter">
![](../Imgs/scan.png)
</div>

## Progressions and Sequences

An arithmetic progression is a succession of numbers such that the **difference**, $d$, of any pair of successive terms in the sequence is constant.
$$a_n = a_1 + (n-1) \ cdot d$$

- ```seq (a, b, by=d)```: to generate an [arithmetic progression](https://es.wikipedia.org/wiki/ArhythmicProgression) of difference $d$ that starts in $to$ up get to $b$
- ```seq (a, b, length.out=n)```: define arithmetic progression of length $n$ ranging from $a$ to $b$ with difference $d$. Therefore $d = (b-a) / (n-1)$
- ```seq (a, by= d, length.out=n)```: define the arithmetic progression of length $n$ and difference $d$ starting in $a$
- ```a:b```: define the sequence of consecutive numbers ** ($\mathbb{Z}$) between two numbers $a$ and $b$

## Example of sequence 

* This is an example of a sequence `r seq(5, 60, by = 3.5)`
* If we want a sequence of **n** lengh we can use `r seq(5, 60, length.out = 7)`
* If we want to start in n number and have a determinate lenght with n step we use `r seq(5, length.out = 7, by = 3)`

## Sequences Exercises

- Numbers sequence from 1 ot 20:  `r 1:20`
- First 20 pair numbers: `r seq(2,by=2, length.out=20)`
- 30 equidistant numbers bettwen 17 and 98 with 4 significative decimals: 
```{r sequence_round, echo=FALSE, results='asis'} 
seqX = seq(17,98, length.out=30)
signif(seqX , digits = 6)
```

## Example of vector 

This is another example to generate a vector, c is also named as concatenation:

```{r concatenation, echo=TRUE}
c(rep(pi, 5), 5:10, -7) -> x
x
c(0, x, 10, x, 20)
```

## Functions

When we want to apply a function to each of the elements of a data vector, the `sapply` function saves us having to program with loops in `R`:

- ''sapply (vector_name, FUN = function_name)'': to apply this function to all vector elements
- ```sqrt(x)```: Calculate a new vector with the square roots of each of the elements of the vector $x$

## Example of use sapply function 

```{r sapply_function_other_topology, echo=TRUE}
x <- 1:10
sapply(x, FUN = function(w){sqrt(w)})
```

```{r sapply_other_topology, echo=TRUE}
sapply(x, function(w)sqrt(w))
```

## Functions

Given a vector of data $x$ we can calculate many statistical measures about it:

- ```length(x)```: Calculate the length of the vector $x$
- ```max(x)```: calculates the maximum of the vector $x$
- ```min(x)```: Calculate the minimum of the vector $x$
- ```sum(x)```: calculates the sum of the entries of the vector $x$
- ```prod(x)```: Calculate the product of the vector entries $x$

## Functions

- ```mean(x)```: calculates the arithmetic mean of the entries in the vector $x$
- ```diff(x)```: calculates the vector formed by the successive differences between entries of the original vector $x$
- ```cumsum(x)```: calculates the vector formed by the cumulative sums of the original vector entries $x$
  - Allows to define sequences described by summation
  - Each entry of ``cumsum(x)`` is the sum of the $x$ entries up to its position
  
## Functions

```{r functions_example}
square_fun = function(x){x^2}
v = c(1,2,3,4,5,6)
sapply(v, FUN = square_fun)
mean(v)
cumsum(v)
```

## Order

- ```sort(x)```: order the vector in natural order of the objects that form it: the increasing numerical order, alphabetical order ...
- ```rev(x)```: invert the order of the vector elements $x$

```{r order_example}
v = c(1,7,5,2,4,6,3)
sort(v)
rev(v)
```

## Order Exercises

```{r order_exercise_one, results='asis'}
v = c(1,7,5,2,4,6,3)
s = sort(v)
rev(s)
```

```{r order_exercise_one_shorter, results='asis'}
v = c(1,7,5,2,4,6,3)
sort(v, decreasing = TRUE)
```

```{r order_exercise_two, results='asis'}
v = c(1,7,5,2,4,6,3)
s = rev(v)
sort(s)
```

## Subvectors

- ```vector[i]```: gives the $i$ -th entry of the vector

  - R indexes start at 1
  - ```vector[length(vector)]```: gives us the last entry of the vector
  - ```vector[a:b]```: if $a$ and $b$ are two natural numbers, the subvector gives us with the entries of the original vector that go from the $to$-th position until the $b$-th.
  - ```vector [-i]```: if $i$ is a number, this subvector is made up of all the entries of the original vector except the $i$ -th entry. If $i$ turns out to be a vector, then it is an index vector and creates a new vector with the entries of the original vector, whose indexes belong to $i$
  - ```vector[-x]```: if $x$ is a vector (of indices), then this is the complement of vector [$x$]
  
## Subvectors

- Also has logic operators:
	
	- ```==```: =
	- ```!=```: $\neq$
	- ```>=```: $\ge$  
	- ```<=```: $\le$
	- ```<```: $<$
	- ```>```: $>$
	- ```!```: NO logic
	- ```&```: AND logic
	- ```|```: OR logic
	
## Subvectors

```{r}
v = c(14,5,6,19,32,0,8)
v[2]
v[-c(3,5)]
v[v != 19 & v>15]
```

## Subvectors

```{r}
w = seq(3, 50, by = 3.5) 
w
w[4:8]
w[8:4]
w[seq(2, length(w), by = 2)]
```

## Subvectors

```{r}
w[seq(1, length(w), by = 2)]
w[-seq(2, length(w), by = 2)]
w[(length(w)-2):length(w)]
w[c(1,5,6)]
```

## Subvectors

```{r}
w[w>30]
w[w>20 & w<40]
w[w!=3 & w!=17]
w[w<10|w>40]
```

## Subvectors

```{r}
w[w>=10]
w[w>10]
w[!w<10]
w[w%%2==0]
w[w%%2==1]
w>30
```

## Subvectors

```{r}
w[w%%2==1]
w>30
```

## Subvectors

If we evaluate one vector in another vector, this will evaluate the **position** that meet the condition, also just can be possible if the two vectors has the same length 

```{r, results='hold'}
x = c(1,7,4,2,4,8,9,2,0)
y = c(5,2,-3,-7,-1,4,-2,7,1)
x
y>0
x[y>0]
```

## Conditional

- ```which(x meets condition)```: to obtain the indexes of the $x$ vector entries that satisfy the given condition
- ```which.min(x)```: gives us the first position in which the vector $x$ takes its minimum value
- ```which(x==min(x))```: gives all the positions in which the vector $x$ takes its minimum values
- ```which.max(x)```: gives us the first position in which the vector $x$ takes its maximum value
- ```which(x ==max(x))```: gives all the positions in which the vector $x$ takes its maximum values

## Conditional

if we use which inside the vector this will return the values, not the positions

```{r}
x
which(x>4)
x[which(x>4)]
x[x>4]
```
## Conditional

The first one shows the positions and the second one shows the values that are in those positions
```{r, results='hold'}
x
which(x<5 | x%%2==0)
x[which(x<5 | x%%2==0)]
```

## Conditional

Display the location of the minimum value that is 0, $which.min(x)$ show just the first value that is found, in this case there is just one 0 so $which(x==min(x))$ will also show the 0
```{r, results='hold'}
x
which.min(x)
which(x==min(x))
```

## Conditional

Display the location of the minimum value that is 0, $which.min(x)$ show just the first value that is found, in this case there is just one 0 so $which(x==min(x))$ will also show the 0
```{r, results='hold'}
x = c(1, 7, 4, 2, 4, 8, 9, 2, 0, 9)
which.max(x)
which(x==max(x))
```

## NA Values

Sometimes vectors has NA values so that we need to attack this cases in the next form:

Dont taking in to account the NA values with $na.rm=true$, this is not recommended.
```{r, results='hold'}
x = c(1, 7, 4, 2, 4, 8, 9, 2, 0, NA, NA, NA, 9)
sum(x, na.rm = TRUE)
mean(x, na.rm =TRUE)
```
## NA Values

We will use instead the function $is.na(somevector)$, this will show us the possition of the **NA values** with a TRUE statement

```{r, results='hold'}
x
is.na(x)
```

Now we can determinate the position with:
```{r, results='hold'}
which(is.na(x))
```
## NA Values

If we want to know the values (already assuming that will show NA) , this are already the values not the positions
```{r} 
x[which(is.na(x))]
```
Now lets write the mean of this vector to fill the NA, this is more recommended than delate the NA

```{r} 
y = x
y[which(is.na(y))] = mean(y, na.rm=TRUE)
y
```
## NA Values

Another way to doesnt take in to account the NA values is with the function:

```{r} 
x
x_clean = na.omit(x)
x_clean
```

## NA Values

This will generate attributes, that can be delated with:

```{r} 
x_clean
attr(x_clean, "na.action") = NULL
attr(x_clean, "class") = NULL
x_clean
```
## Factors

<l class = "definition"> Factor</l>: it's like a vector, but with a richer internal structure that allows it to be used to classify observations

- `levels`: factor attribute. Each element of the factor is equal to one level. The levels classify the inputs of the factor. They are sorted alphabetically
- To define a factor, we must first define a vector and transform it by means of one of the functions `factor()` or `as.factor()`.

```{r} 
gender = c("M", "F", "M", "F", "F", "F", "F", "M", "M")
gender.fact = factor(gender)
gender.fact
```
## Factors

Another way to express a factor 
 
```{r} 
gender.fact2 = as.factor(gender)
gender.fact2
```
## Modify a factors

Is possible to add more levels

```{r} 
gender.fact3 = factor(gender, levels = c("M", "F", "B"))
gender.fact3
```
## Modify a factors

Is possible to add labels

```{r} 
gender.fact4 = factor(gender, levels = c("M", "F", "B"), labels = c("Male", "Female", "Bisexual"))
gender.fact4
```

## Check levels of a factor

To check the levels that hold a factor 

```{r} 
levels(gender.fact)
levels(gender.fact4)
```
## Modify level of a factor

To check the levels that hold a factor 

```{r} 
levels(gender.fact4) = c("Male", "Female", "Bi")
gender.fact4
```

## Example

```{r} 
note = c(1,2,3,4,4,3,4,3,2,1,2,3,4)
note.fact = factor(note)
note.fact
```

## Example

```{r} 
levels(note.fact)
levels(note.fact) = c("fail", "good", "very good", "excellent")
note.fact
```

## Example

Is possible to group different levels 

```{r} 
note
levels(note.fact) = c("fail", "good", "good", "good")
note.fact
```

## Ordered factor

<l class = "definition"> Ordered factor.</l> It is a factor where the levels follow an order

- `ordered (vector, levels = ...)`: function that defines an ordered factor and has the same parameters as factor

## Ordered factor

```{r} 
note
ordered(note, labels = c("fail", "good", "very good", "excellent"))
```

## Ordered factor example

```{r}
fac = factor(c(1,1,1,2,2,3,2,4,1,3,3,4,2,3,4,4), 
       levels = c(1,2,3,4), labels = c("Sus","Apr","Not","Exc"))
fac
facOrd = ordered(c(1,1,1,2,2,3,2,4,1,3,3,4,2,3,4,4), 
       levels = c(1,2,3,4), labels = c("Sus","Apr","Not","Exc"))
facOrd
```